@page "/upload-file"

@inject HttpClient HttpClient
@rendermode InteractiveWebAssembly
@attribute [Authorize]

@_authenticationState.User.Claims.FirstOrDefault(x => x.Type == ClaimTypes.NameIdentifier)?.Value

@if (RendererInfo.IsInteractive)
{
    <h3>File Upload with Speed Limit</h3>
    <InputFile OnChange="OnFileChange" multiple id="@InputFileId" />
    <br />
    <progress max="100" value="@_uploadProgress"></progress>
    <br />
    <button class="btn btn-primary my-3" disabled="@_disableButton" @onclick="HandleUploadFile">Upload</button>
    <br />
    <p>@_uploadProgress%</p>
    <p>Speed: @_uploadSpeed KB/s</p>
}
else
{
    <p>Waiting...</p>
}

@code {
    private const string InputFileId = "fileInput";
    private int _uploadProgress;
    private double _uploadSpeed;
    private const int ChunkSize = 2 * 1024 * 1024;
    private const int BufferSize = 1 * 1024 * 1024;
    private const double MaxUploadSpeed = 5 * 1024 * 1024;
    private SeekableFileStream _fileStream = null!;
    [Inject] public ILogger<UploadFile> Logger { get; set; } = null!;
    [Inject] public IJSRuntime JsRuntime { get; set; } = null!;

    [CascadingParameter] public Task<AuthenticationState> AuthenticationStateTask { get; set; } = null!;
    private AuthenticationState _authenticationState = null!;

    private bool _disableButton;
    private IBrowserFile? _browserFile;

    protected override async Task OnInitializedAsync()
    {
        _authenticationState = await AuthenticationStateTask;
    }

    private Task OnFileChange(InputFileChangeEventArgs e)
    {
        _disableButton = false;
        _browserFile = e.File;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private async Task HandleUploadFile()
    {
        if (_browserFile == null) return;

        _fileStream = new SeekableFileStream(JsRuntime, InputFileId, 0, _browserFile.Size);
        _disableButton = true;
        StateHasChanged();

        var fileInfo = await InitUploadAsync(_fileStream);

        if (fileInfo.IsCompleted)
        {
            await JsRuntime.InvokeVoidAsync("alert", $"File {fileInfo.FileName} already uploaded");
            return;
        }

        _fileStream.Seek(fileInfo.UploadedBytes, SeekOrigin.Begin);

        var buffer = new byte[ChunkSize];

        long totalBytesRead = fileInfo.UploadedBytes, totalBytes = _browserFile.Size;

        while (totalBytesRead < totalBytes)
        {
            var startChunkTime = DateTime.UtcNow;
            var chunkBytesRead = 0;

            while (chunkBytesRead < ChunkSize)
            {
                var readCount = Math.Min(BufferSize, ChunkSize - chunkBytesRead);
                var bytesRead = await _fileStream.ReadAsync(buffer, chunkBytesRead, readCount, CancellationToken.None);
                if (bytesRead == 0) break;
                chunkBytesRead += bytesRead;
            }

            totalBytesRead += chunkBytesRead;

            var content = new MultipartFormDataContent
            {
                { new ByteArrayContent(buffer, 0, chunkBytesRead), "chunkFile", _browserFile.Name },
            };

            await HttpClient.PostAsync($"api/upload/chunk/{fileInfo.Id}", content);

            var elapsedSeconds = (DateTime.UtcNow - startChunkTime).TotalSeconds;

            var minTimeForChunk = ChunkSize / MaxUploadSpeed;
            var remainingTime = minTimeForChunk - elapsedSeconds;

            if (remainingTime > 0)
            {
                await Task.Delay(TimeSpan.FromSeconds(remainingTime));
            }

            var totalChunkTime = (DateTime.UtcNow - startChunkTime).TotalSeconds;
            if (totalChunkTime > 0)
            {
                _uploadSpeed = Math.Round((chunkBytesRead / 1024.0) / totalChunkTime, 2);
            }

            _uploadProgress = (int)(totalBytesRead * 100.0 / totalBytes);
            StateHasChanged();
        }

        await _fileStream.DisposeAsync();
        _uploadProgress = 100;
        StateHasChanged();
    }

    private static async Task<string> ComputeFileFingerprintAsync(SeekableFileStream file)
    {
        using var sha256 = SHA256.Create();

        const int chunkSize = 512 * 1024;//512KB
        var bufferSize = (int)Math.Min(chunkSize, file.Length);
        var buffer = new byte[bufferSize];

        _ = await file.ReadAsync(buffer, 0, bufferSize);

        sha256.TransformBlock(buffer, 0, bufferSize, buffer, 0);

        sha256.TransformFinalBlock([], 0, 0);

        var hashBytes = sha256.Hash!;
        return BitConverter.ToString(hashBytes).Replace("-", "").ToLower();
    }

    private async Task<UploadInfoDto> InitUploadAsync(SeekableFileStream fileStream)
    {
        if (_browserFile == null) throw new ArgumentException(nameof(_browserFile));

        var fileChecksum = await ComputeFileFingerprintAsync(fileStream);

        var metadata = new UploadInfoDto
            {
                FileName = _browserFile.Name,
                FileSize = _browserFile.Size,
                ContentType = _browserFile.ContentType,
                Checksum = fileChecksum,
                Type = VideoEnum.VideoType.Other,
                UserId = _authenticationState.GetUserId()
            };

        var response = await HttpClient.PostAsJsonAsync("api/upload/init", metadata);
        response.EnsureSuccessStatusCode();

        var uploadInfo = await response.Content.ReadFromJsonAsync<UploadInfoDto>();

        return uploadInfo!;
    }

}
